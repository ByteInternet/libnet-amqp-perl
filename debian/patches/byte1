Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 libnet-amqp-perl (0.06~dfsg-1byte1) unstable; urgency=low
 .
   * Hack around 32-bit incompatibility
Author: Maarten van Schaik <maarten@byte.nl>

--- libnet-amqp-perl-0.06~dfsg.orig/lib/Net/AMQP/Common.pm
+++ libnet-amqp-perl-0.06~dfsg/lib/Net/AMQP/Common.pm
@@ -83,6 +83,7 @@ use strict;
 use warnings;
 use Scalar::Util qw( blessed reftype );
 use Net::AMQP::Value;
+use Config;
 use base qw(Exporter);
 
 BEGIN {
@@ -127,23 +128,51 @@ our %data_type_map = (
     array     => 'field_array',
 );
 
+our $_64bit = (defined $Config{use64bitint} || $Config{longsize} >= 8);
+
 sub pack_boolean                       {      pack 'C', shift() ? 1 : 0 }
 sub pack_octet                         {      pack 'C', shift || 0 }
 sub pack_short_integer                 { _big pack 's', shift || 0 }
 sub pack_long_integer                  { _big pack 'l', shift || 0 }
-sub pack_long_long_integer             { _big pack 'q', shift || 0 }
+sub pack_long_long_integer {
+    if ($_64bit) {
+        return _big pack 'q', shift || 0;
+    }
+    else {
+        return pack('l', 0) . _big pack 'l', shift || 0;
+    }
+}
 sub pack_unsigned_short_integer        {      pack 'n', shift || 0 }
 sub pack_unsigned_long_integer         {      pack 'N', shift || 0 }
-sub pack_unsigned_long_long_integer    { _big pack 'Q', shift || 0 }
+sub pack_unsigned_long_long_integer {
+    if ($_64bit) {
+        return _big pack('Q', shift || 0);
+    } else {
+        return pack('l', 0) . pack('N', shift || 0);
+    }
+}
 
 sub unpack_boolean                     { unpack 'C',      substr ${+shift}, 0, 1, '' }
 sub unpack_octet                       { unpack 'C',      substr ${+shift}, 0, 1, '' }
 sub unpack_short_integer               { unpack 's', _big substr ${+shift}, 0, 2, '' }
 sub unpack_long_integer                { unpack 'l', _big substr ${+shift}, 0, 4, '' }
-sub unpack_long_long_integer           { unpack 'q', _big substr ${+shift}, 0, 8, '' }
+sub unpack_long_long_integer {
+    if ($_64bit) {
+        return unpack 'q', _big substr ${+shift}, 0, 8, '';
+    } else {
+        return unpack 'l', _big substr ${+shift}, 0, 8, '';
+    }
+}
 sub unpack_unsigned_short_integer      { unpack 'n',      substr ${+shift}, 0, 2, '' }
 sub unpack_unsigned_long_integer       { unpack 'N',      substr ${+shift}, 0, 4, '' }
-sub unpack_unsigned_long_long_integer  { unpack 'Q', _big substr ${+shift}, 0, 8, '' }
+sub unpack_unsigned_long_long_integer {
+    if ($_64bit) {
+        return unpack 'Q', _big substr(${+shift}, 0, 8, '');
+    } else {
+        my $part = substr(${+shift}, 0, 8, '');
+        return unpack 'N', substr($part, 4);
+    }
+}
 
 sub pack_timestamp   { goto &pack_unsigned_long_long_integer }
 sub unpack_timestamp { goto &unpack_unsigned_long_long_integer }
